initSidebarItems({"constant":[["IO_VIRTUAL_BASE",""]],"enum":[["StivaleMemoryMapEntryType","The type of a memory map entry. The entries are guaranteed to be sorted by base address, lowest to highest."]],"fn":[["aero_main",""],["kernel_ap_startup",""],["kernel_main_thread",""]],"macro":[["module_init",""]],"mod":[["acpi","The ACPI (Advanced Configuration and Power Interface) tables help to gather the CPU, interrupt, and timer informations."],["apic",""],["arch",""],["cmdline",""],["drivers",""],["fs",""],["logger",""],["mem",""],["modules","A kernel module is an object file that contains code that can extend the kernel functionality at runtime. When a kernel module is no longer needed, it can be unloaded. Most of the device drivers are used in the form of kernel modules."],["prelude",""],["rendy",""],["syscall","System Calls are used to call a kernel service from userland."],["tests",""],["time","The PIT (Programmable Interval Timer) chip basically consists of an oscillator, a prescaler and 3 independent frequency dividers and it is used to create time intervals and calculate estimate time since epoch."],["tls","Thread Local Storage (TLS) are per-thread global variables. On 64-bit each CPU core’s `fs` GDT segment points to the thread local memory area where the thread local static’s live. TLS statics are simply accessed through an offset from `fs`."],["unwind",""],["userland",""],["utils",""]],"static":[["AERO_SYSTEM_ALLOCATOR",""],["CPU_ID",""],["PHYSICAL_MEMORY_OFFSET",""],["UNWIND_INFO",""]],"struct":[["Stivale5LevelPagingHeaderTag","If this tag is present the bootloader is instructed to enable upport for 5-level paging, if available."],["StivaleAnyVideoTag","This tag tells the bootloader that the kernel has no requirement for a framebuffer to be initialised. Omitting both the any video header tag and the framebuffer header tag means “force CGA text mode” (where available), and the bootloader will refuse to boot the kernel if it fails to fulfill that request."],["StivaleCommandLineTag","This tag is used to get the kernel the command line string that was passed to it by the bootloader."],["StivaleDeviceTreeTag","This tag describes a device tree blob for the platform."],["StivaleEdidInfoTag","This tag is used to get the EDID information as acquired by the firmware."],["StivaleEfiSystemTableTag","This tag is used to get a pointer to the EFI system table if available."],["StivaleEpochTag","This tag is used to get the current UNIX epoch, as per RTC."],["StivaleFirmwareTag","This tag is used to get the info about the firmware."],["StivaleFirmwareTagFlags","Bitfield representing the firmware and boot flags passed by the bootloader."],["StivaleFramebufferHeaderTag","If this tag is present the bootloader is instructed to initialise a graphical framebuffer video mode. Omitting this tag will make the bootloader default to a CGA-compatible text mode, if supported."],["StivaleFramebufferTag","If the framebuffer tag was requested through the framebuffer tag header and its supported by the stivale bootloader, this tag is returned to the kernel. This tag provides an interface to the framebuffer."],["StivaleHeader",""],["StivaleKernelFileTag","This tag is used to get the kernel with a pointer to a copy the raw executable file of the kernel that the bootloader loaded."],["StivaleKernelFileV2Tag",""],["StivaleKernelSlideTag","This tag is used to get the slide that the bootloader applied over the kernel’s load address as a positive offset."],["StivaleMemoryMapEntry",""],["StivaleMemoryMapIter","Iterator over all the memory regions provided by the stivale bootloader."],["StivaleMemoryMapTag",""],["StivaleModule","Structure representing a module, containing the information of a module that the bootloader loaded alongside the kernel."],["StivaleModuleIter","Iterator over all the modules that were loaded."],["StivaleModuleTag","This tag is used to get the modules that the bootloader loaded alongside the kernel, if any."],["StivaleMtrrHeaderTag","This tag tells the bootloader to, in case a framebuffer was requested, make that framebuffer’s caching type write-combining using x86’s MTRR model specific registers. This caching type helps speed up framebuffer writes on real hardware."],["StivaleMtrrTag","This tag exists if MTRR write-combining for the framebuffer was requested and successfully enabled. See the documentation of [crate::v2::header::StivaleMtrrHeaderTag] for more information."],["StivalePmr",""],["StivalePmrPermissionFlags",""],["StivalePmrsTag",""],["StivalePxeInfoTag","This tag reports that the kernel has been booted via PXE, and reports the server ip that it was booted from."],["StivaleRsdpTag","This tag is used to get the location of the ACPI RSDP structure in memory."],["StivaleSmbiosTag","This tag is used to get the location of the SMBIOS entry points in memory."],["StivaleSmpHeaderTag",""],["StivaleSmpHeaderTagFlags","Bitfield representing the SMP header flags passed to the bootloader."],["StivaleSmpInfo","SMP imformation structure."],["StivaleSmpTag",""],["StivaleStruct",""],["StivaleTagHeader",""],["StivaleTerminalHeaderTag","If this tag is present the bootloader is instructed to set up a terminal for use by the kernel at runtime. See “Terminal struct tag” below. The framebuffer header tag must be specified when passing this header tag, and this tag may inhibit the WC MTRR framebuffer feature."],["StivaleTerminalTag","If the terminal tag was requested through the terminal tag header and its supported by the stivale bootloader, this tag is returned to the kernel. This tag provides an interface to the stivale terminal."],["StivaleUartTag","This tag reports that there is a memory mapped UART port and its address."],["StivaleUnmapNullHeaderTag","If this tag is present the bootloader is instructed to unmap the first page of the virtual address space before passing control to the kernel, for architectures that support paging."],["StivaleVMapTag","This tag describes the high physical memory location."]]});