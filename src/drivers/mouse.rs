use crate::utils::io;

const MOUSE_WAIT_TIMEOUT: usize = 100000;

// const PS2_LEFT_BUTTON: u8 = 0b00000001;
// const PS2_MIDDLE_BUTTON: u8 = 0b00000100;
// const PS2_RIGHT_BUTTON: u8 = 0b00000010;

const PS2_X_SIGN: u8 = 0b00010000;
const PS2_Y_SIGN: u8 = 0b00100000;

const PS2_X_OVERFLOW: u8 = 0b01000000;
const PS2_Y_OVERFLOW: u8 = 0b10000000;

static mut MOUSE_CYCLE: u8 = 0;
static mut MOUSE_PACKET: [u8; 4] = [0; 4];
static mut MOUSE_PACKET_READY: bool = false;
static mut MOUSE_POSITION: MousePoition = MousePoition::new();

#[derive(Debug)]
struct MousePoition {
    x: i64,
    y: i64,
}

impl MousePoition {
    /// Create a new mouse position.
    const fn new() -> Self {
        Self { x: 0, y: 0 }
    }
}

unsafe fn mouse_wait() {
    for _ in 0..MOUSE_WAIT_TIMEOUT {
        if io::inb(0x64 & 0b10) == 0 {
            return;
        }
    }
}

unsafe fn mouse_wait_input() {
    for _ in 0..MOUSE_WAIT_TIMEOUT {
        if io::inb(0x64) & 0b1 == 1 {
            return;
        }
    }
}

unsafe fn mouse_write(value: u8) {
    io::outb(0x64, 0xD4);
    mouse_wait();

    io::outb(0x60, value);
}

/// Handle the mouse interrupt.
pub unsafe fn handle(data: u8) {
    if !MOUSE_PACKET_READY {
        match MOUSE_CYCLE {
            0 => {
                if data & 0b00001000 != 0 {
                    MOUSE_PACKET[0] = data;
                    MOUSE_CYCLE += 1;
                }
            }

            1 => {
                MOUSE_PACKET[1] = data;
                MOUSE_CYCLE += 1;
            }

            2 => {
                MOUSE_PACKET[2] = data;

                MOUSE_PACKET_READY = true;
                MOUSE_CYCLE = 0;
            }

            _ => unreachable!(),
        }
    }
}

/// Process the mouse packet generated by mouse interrupts.
pub unsafe fn process_mouse_packet() {
    if MOUSE_PACKET_READY {
        MOUSE_PACKET_READY = false;

        let (mut x_negative, mut y_negative) = (false, false);
        let (mut x_overflow, mut y_overflow) = (false, false);

        if MOUSE_PACKET[0] & PS2_X_SIGN == 1 {
            x_negative = true;
        }

        if MOUSE_PACKET[0] & PS2_Y_SIGN == 1 {
            y_negative = true;
        }

        if MOUSE_PACKET[0] & PS2_X_OVERFLOW == 1 {
            x_overflow = true;
        }

        if MOUSE_PACKET[0] & PS2_Y_OVERFLOW == 1 {
            y_overflow = true;
        }

        if !x_negative {
            MOUSE_POSITION.x += MOUSE_PACKET[1] as i64;

            if x_overflow {
                MOUSE_POSITION.x += 255;
            }
        } else {
            MOUSE_POSITION.x -= MOUSE_PACKET[1] as i64;

            if x_overflow {
                MOUSE_POSITION.x -= 255;
            }
        }

        if !y_negative {
            MOUSE_POSITION.y -= MOUSE_PACKET[2] as i64;

            if y_overflow {
                MOUSE_POSITION.y -= 255;
            }
        } else {
            MOUSE_POSITION.y += MOUSE_PACKET[2] as i64;

            if y_overflow {
                MOUSE_POSITION.y += 255;
            }
        }

        // Check if our mouse position does not overflow the frame buffer width and height.
        if MOUSE_POSITION.x < 0 {
            MOUSE_POSITION.x = 0
        }

        if MOUSE_POSITION.y < 0 {
            MOUSE_POSITION.y = 0
        }
    }
}

/// Initialise the PS/2 Mouse.
pub fn init() {
    unsafe {
        // Enable the auxiliary device - mouse.
        io::outb(0x64, 0xA8);
        mouse_wait();

        // Inform the keyboard controller that we want to send a command to the mouse.
        io::outb(0x64, 0x20);
        mouse_wait_input();

        let mut status = io::inb(0x60);

        status |= 0b10;
        mouse_wait();

        io::outb(0x64, 0x60);
        mouse_wait();

        io::outb(0x60, status);
        mouse_wait();

        // 0xF6 is the default settings for the mouse.
        mouse_write(0xF6);

        mouse_wait_input();
        io::inb(0x60);

        mouse_write(0xF4);

        mouse_wait_input();
        io::inb(0x60);
    }
}
