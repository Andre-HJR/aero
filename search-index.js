var searchIndex = JSON.parse('{\
"aero":{"doc":"AeroAero is a new modern, unix based operating system. It …","i":[[0,"drivers","aero","",null,null],[0,"keyboard","aero::drivers","",null,null],[17,"LEFT_SHIFT_PRESSED","aero::drivers::keyboard","",null,null],[17,"LEFT_SHIFT_RELEASED","","",null,null],[17,"RIGHT_SHIFT_PRESSED","","",null,null],[17,"RIGHT_SHIFT_RELEASED","","",null,null],[17,"SPACEBAR_PRESSED","","",null,null],[17,"ENTER_PRESSED","","",null,null],[17,"BACKSPACE_PRESSED","","",null,null],[17,"ASCII_TABLE","","",null,null],[7,"IS_LEFT_SHIFT_PRESSED","","",null,null],[7,"IS_RIGHT_SHIFT_PRESSED","","",null,null],[5,"translate_keystroke","","",null,[[]]],[5,"handle","","",null,[[]]],[0,"gdt","aero","",null,null],[0,"gdt","aero::gdt","The GDT contains entries telling the CPU about memory …",null,null],[5,"LoadGDT","aero::gdt::gdt","Load the GDT using inline assembly.",null,null],[3,"GDTDescriptor","","The GDT Descriptor containing the size of offset of the …",null,null],[12,"size","","The size of the table subtracted by 1. The size of the …",0,null],[12,"offset","","The linear address of the table.",0,null],[11,"new","","Create a new GDT descriptor.",0,[[]]],[3,"GDTEntry","","",null,null],[12,"limit_low","","",1,null],[12,"base_low","","",1,null],[12,"base_middle","","",1,null],[12,"access_byte","","",1,null],[12,"limit_hi_flags","","The limit high and the flags.",1,null],[12,"base_hi","","",1,null],[11,"new","","Create a new GDT entry.",1,[[]]],[3,"GDT","","The GDT.",null,null],[12,"kernel_null","","The kernel null segment: <code>0x00</code>.",2,null],[12,"kernel_code","","The kernel code segment: <code>0x08</code>.",2,null],[12,"kernel_data","","The kernel data segment: <code>0x10</code>.",2,null],[12,"user_null","","The user null segment.",2,null],[12,"user_code","","The user code segment.",2,null],[12,"user_data","","The user data segment.",2,null],[5,"init","","Initialize the GDT.",null,[[]]],[3,"GLOBAL_DESCRIPTOR_TABLE","","The GDT (Global Descriptor Table).",null,null],[12,"__private_field","","",3,null],[0,"interrupts","aero","",null,null],[0,"exceptions","aero::interrupts","",null,null],[5,"divide_by_zero","aero::interrupts::exceptions","",null,[[]]],[5,"debug","","",null,[[]]],[5,"non_maskable","","",null,[[]]],[5,"breakpoint","","",null,[[]]],[5,"overflow","","",null,[[]]],[5,"bound_range","","",null,[[]]],[5,"invalid_opcode","","",null,[[]]],[5,"device_not_available","","",null,[[]]],[5,"double_fault","","",null,[[]]],[5,"invalid_tss","","",null,[[]]],[5,"page_fault","","",null,[[]]],[0,"idt","aero::interrupts","The IDT is similar to the Global Descriptor Table in …",null,null],[17,"IDT_ENTRIES","aero::interrupts::idt","Declare an IDT of 256 entries. Although not all entries …",null,null],[17,"PIC1_COMMAND","","",null,null],[17,"PIC1_DATA","","",null,null],[17,"PIC2_COMMAND","","",null,null],[17,"PIC2_DATA","","",null,null],[17,"PIC_EOI","","",null,null],[17,"ICW1_INIT","","",null,null],[17,"ICW1_ICW4","","",null,null],[17,"ICW4_8086","","",null,null],[6,"IDTInterruptHandlerFn","","",null,null],[7,"IDT","","",null,null],[3,"IDTFlags","","",null,null],[12,"bits","","",4,null],[18,"PRESENT","","",4,null],[18,"RING_0","","",4,null],[18,"RING_1","","",4,null],[18,"RING_2","","",4,null],[18,"RING_3","","",4,null],[18,"SS","","",4,null],[18,"INTERRUPT","","",4,null],[18,"TRAP","","",4,null],[11,"empty","","Returns an empty set of flags",4,[[],["idtflags",3]]],[11,"all","","Returns the set containing all flags.",4,[[],["idtflags",3]]],[11,"bits","","Returns the raw value of the flags currently stored.",4,[[]]],[11,"from_bits","","Convert from underlying bit representation, unless that …",4,[[],[["idtflags",3],["option",4]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any …",4,[[],["idtflags",3]]],[11,"from_bits_unchecked","","Convert from underlying bit representation, preserving all…",4,[[],["idtflags",3]]],[11,"is_empty","","Returns <code>true</code> if no flags are currently stored.",4,[[]]],[11,"is_all","","Returns <code>true</code> if all flags are currently set.",4,[[]]],[11,"intersects","","Returns <code>true</code> if there are flags common to both <code>self</code> and …",4,[[["idtflags",3]]]],[11,"contains","","Returns <code>true</code> all of the flags in <code>other</code> are contained …",4,[[["idtflags",3]]]],[11,"insert","","Inserts the specified flags in-place.",4,[[["idtflags",3]]]],[11,"remove","","Removes the specified flags in-place.",4,[[["idtflags",3]]]],[11,"toggle","","Toggles the specified flags in-place.",4,[[["idtflags",3]]]],[11,"set","","Inserts or removes the specified flags depending on the …",4,[[["idtflags",3]]]],[3,"IDTDescriptor","","",null,null],[12,"size","","",5,null],[12,"offset","","",5,null],[11,"new","","Create a new IDT descriptor.",5,[[]]],[3,"IDTEntry","","",null,null],[12,"offset_low","","",6,null],[12,"selector","","",6,null],[12,"ist","","",6,null],[12,"type_attr","","",6,null],[12,"offset_middle","","",6,null],[12,"offset_hi","","",6,null],[12,"ignore","","",6,null],[11,"null","","Create a new IDT entry with all values defaulted to 0, ie …",6,[[]]],[11,"set_flags","","Set the IDT entry flags.",6,[[["idtflags",3]]]],[11,"set_offset","","Set the IDT entry offset.",6,[[]]],[11,"set_function","","Set the handler function of the IDT entry.",6,[[]]],[5,"init","","Initialize the IDT.",null,[[]]],[5,"load_idt","","Load the IDT using inline assembly.",null,[[]]],[5,"enable_interrupts","","Enable interrupts.",null,[[]]],[5,"end_pic1","","",null,[[]]],[5,"load_pic","","",null,[[]]],[0,"irq","aero::interrupts","",null,null],[5,"pit","aero::interrupts::irq","",null,[[]]],[5,"keyboard","","",null,[[]]],[0,"panic","aero","",null,null],[5,"panic","aero::panic","",null,[[["panicinfo",3]]]],[0,"pit","aero","The PIT (Programmable Interval Timer) chip basically …",null,null],[3,"PITDescriptor","aero::pit","",null,null],[12,"ticks_since_epoch","","CPU ticks since epoch.",7,null],[11,"new","","Create a new PIT descriptor.",7,[[]]],[11,"sleep","","",7,[[["duration",3]]]],[11,"tick","","Increments ticks since epoch. This function is called on …",7,[[]]],[11,"get_ticks_since_epoch","","Get the CPU ticks since epoch.",7,[[]]],[7,"PIT","","The PIT (Programmable Interval Timer)",null,null],[5,"init","","Initialise the PIT chip.",null,[[]]],[0,"tests","aero","",null,null],[0,"utils","","",null,null],[0,"io","aero::utils","Wrapper functions for the hardware IO using respective …",null,null],[5,"outb","aero::utils::io","Wrapper function to the <code>outb</code> assembly instruction used to …",null,[[]]],[5,"inb","","Wrapper function to the <code>inb</code> assembly instruction used to …",null,[[]]],[5,"wait","","This function is called after every <code>outb</code> instruction as …",null,[[]]],[0,"vga","aero","",null,null],[0,"buffer","aero::vga","",null,null],[17,"BUFFER_HEIGHT","aero::vga::buffer","",null,null],[17,"BUFFER_WIDTH","","",null,null],[3,"ScreenChar","","",null,null],[12,"character","","",8,null],[12,"color_code","","",8,null],[3,"Buffer","","",null,null],[12,"chars","","",9,null],[0,"color","aero::vga","",null,null],[4,"Color","aero::vga::color","",null,null],[13,"Black","","",10,null],[13,"Blue","","",10,null],[13,"Green","","",10,null],[13,"Cyan","","",10,null],[13,"Red","","",10,null],[13,"Magenta","","",10,null],[13,"Brown","","",10,null],[13,"LightGray","","",10,null],[13,"DarkGray","","",10,null],[13,"LightBlue","","",10,null],[13,"LightGreen","","",10,null],[13,"LightCyan","","",10,null],[13,"LightRed","","",10,null],[13,"Pink","","",10,null],[13,"Yellow","","",10,null],[13,"White","","",10,null],[3,"ColorCode","","",null,null],[12,"0","","",11,null],[11,"new","","",11,[[["color",4]],["colorcode",3]]],[0,"rendy","aero::vga","",null,null],[3,"RENDERER","aero::vga::rendy","",null,null],[12,"__private_field","","",12,null],[3,"Rendy","","",null,null],[12,"column_position","","",13,null],[12,"color_code","","",13,null],[12,"buffer","","",13,null],[11,"string","","",13,[[]]],[11,"byte","","",13,[[]]],[11,"new_line","","",13,[[]]],[11,"clear_row","","",13,[[]]],[11,"clear_screen","","",13,[[]]],[11,"clear_current","","",13,[[]]],[0,"log","aero","",null,null],[5,"info","aero::log","",null,[[]]],[5,"__impl_start","aero","",null,[[["bootinfo",3]]]],[5,"kernel_main","","",null,[[["bootinfo",3]]]],[14,"print","","",null,null],[14,"println","","",null,null],[11,"from","aero::gdt::gdt","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"into","","",3,[[]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","aero::interrupts::idt","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"into","","",4,[[]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"into","","",5,[[]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","","",6,[[]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"into","","",6,[[]]],[11,"try_into","","",6,[[],["result",4]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","aero::pit","",7,[[]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"into","","",7,[[]]],[11,"try_into","","",7,[[],["result",4]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"from","aero::vga::buffer","",8,[[]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"into","","",8,[[]]],[11,"try_into","","",8,[[],["result",4]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"from","","",9,[[]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"into","","",9,[[]]],[11,"try_into","","",9,[[],["result",4]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"from","aero::vga::color","",10,[[]]],[11,"borrow","","",10,[[]]],[11,"borrow_mut","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"into","","",10,[[]]],[11,"try_into","","",10,[[],["result",4]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"from","","",11,[[]]],[11,"borrow","","",11,[[]]],[11,"borrow_mut","","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"into","","",11,[[]]],[11,"try_into","","",11,[[],["result",4]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"from","aero::vga::rendy","",12,[[]]],[11,"borrow","","",12,[[]]],[11,"borrow_mut","","",12,[[]]],[11,"try_from","","",12,[[],["result",4]]],[11,"into","","",12,[[]]],[11,"try_into","","",12,[[],["result",4]]],[11,"type_id","","",12,[[],["typeid",3]]],[11,"from","","",13,[[]]],[11,"borrow","","",13,[[]]],[11,"borrow_mut","","",13,[[]]],[11,"try_from","","",13,[[],["result",4]]],[11,"into","","",13,[[]]],[11,"try_into","","",13,[[],["result",4]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"deref","aero::gdt::gdt","",3,[[],["gdt",3]]],[11,"deref","aero::vga::rendy","",12,[[],["mutex",3]]],[11,"fmt","aero::interrupts::idt","",4,[[["formatter",3]],["result",6]]],[11,"fmt","aero::vga::buffer","",8,[[["formatter",3]],["result",6]]],[11,"fmt","aero::vga::color","",10,[[["formatter",3]],["result",6]]],[11,"fmt","","",11,[[["formatter",3]],["result",6]]],[11,"sub","aero::interrupts::idt","Returns the set difference of the two sets of flags.",4,[[["idtflags",3]],["idtflags",3]]],[11,"eq","","",4,[[["idtflags",3]]]],[11,"ne","","",4,[[["idtflags",3]]]],[11,"eq","aero::vga::buffer","",8,[[["screenchar",3]]]],[11,"ne","","",8,[[["screenchar",3]]]],[11,"eq","aero::vga::color","",10,[[["color",4]]]],[11,"eq","","",11,[[["colorcode",3]]]],[11,"ne","","",11,[[["colorcode",3]]]],[11,"cmp","aero::interrupts::idt","",4,[[["idtflags",3]],["ordering",4]]],[11,"partial_cmp","","",4,[[["idtflags",3]],[["ordering",4],["option",4]]]],[11,"lt","","",4,[[["idtflags",3]]]],[11,"le","","",4,[[["idtflags",3]]]],[11,"gt","","",4,[[["idtflags",3]]]],[11,"ge","","",4,[[["idtflags",3]]]],[11,"sub_assign","","Disables all flags enabled in the set.",4,[[["idtflags",3]]]],[11,"not","","Returns the complement of this set of flags.",4,[[],["idtflags",3]]],[11,"bitand","","Returns the intersection between the two sets of flags.",4,[[["idtflags",3]],["idtflags",3]]],[11,"bitor","","Returns the union of the two sets of flags.",4,[[["idtflags",3]],["idtflags",3]]],[11,"bitxor","","Returns the left flags, but with all the right flags …",4,[[["idtflags",3]],["idtflags",3]]],[11,"bitand_assign","","Disables all flags disabled in the set.",4,[[["idtflags",3]]]],[11,"bitor_assign","","Adds the set of flags.",4,[[["idtflags",3]]]],[11,"bitxor_assign","","Toggles the set of flags.",4,[[["idtflags",3]]]],[11,"hash","","",4,[[]]],[11,"write_str","aero::vga::rendy","",13,[[],["result",6]]],[11,"from_iter","aero::interrupts::idt","",4,[[["intoiterator",8]],["idtflags",3]]],[11,"fmt","","",4,[[["formatter",3]],["result",6]]],[11,"fmt","","",4,[[["formatter",3]],["result",6]]],[11,"fmt","","",4,[[["formatter",3]],["result",6]]],[11,"fmt","","",4,[[["formatter",3]],["result",6]]],[11,"extend","","",4,[[["intoiterator",8]]]],[11,"clone","","",4,[[],["idtflags",3]]],[11,"clone","","",6,[[],["idtentry",3]]],[11,"clone","aero::vga::buffer","",8,[[],["screenchar",3]]],[11,"clone","aero::vga::color","",10,[[],["color",4]]],[11,"clone","","",11,[[],["colorcode",3]]],[11,"initialize","aero::gdt::gdt","",3,[[]]],[11,"initialize","aero::vga::rendy","",12,[[]]]],"p":[[3,"GDTDescriptor"],[3,"GDTEntry"],[3,"GDT"],[3,"GLOBAL_DESCRIPTOR_TABLE"],[3,"IDTFlags"],[3,"IDTDescriptor"],[3,"IDTEntry"],[3,"PITDescriptor"],[3,"ScreenChar"],[3,"Buffer"],[4,"Color"],[3,"ColorCode"],[3,"RENDERER"],[3,"Rendy"]]},\
"bitflags":{"doc":"A typesafe bitmask flag generator useful for sets of …","i":[[14,"bitflags","bitflags","The macro used to generate the flag structure.",null,null]],"p":[]},\
"bootloader":{"doc":"This library part of the bootloader allows kernels to …","i":[[0,"bootinfo","bootloader","Provides boot information to the kernel.",null,null],[3,"MemoryMap","bootloader::bootinfo","A map of the physical memory regions of the underlying …",null,null],[3,"MemoryRegion","","Represents a region of physical memory.",null,null],[12,"range","","The range of frames that belong to the region.",0,null],[12,"region_type","","The type of the region.",0,null],[3,"FrameRange","","A range of frames with an exclusive upper bound.",null,null],[12,"start_frame_number","","The frame <em>number</em> of the first 4KiB frame in the region.",1,null],[12,"end_frame_number","","The frame <em>number</em> of the first 4KiB frame that does no …",1,null],[4,"MemoryRegionType","","Represents possible types for memory regions.",null,null],[13,"Usable","","Unused memory, can be freely used by the kernel.",2,null],[13,"InUse","","Memory that is already in use.",2,null],[13,"Reserved","","Memory reserved by the hardware. Not usable.",2,null],[13,"AcpiReclaimable","","ACPI reclaimable memory",2,null],[13,"AcpiNvs","","ACPI NVS memory",2,null],[13,"BadMemory","","Area containing bad memory",2,null],[13,"Kernel","","Memory used for loading the kernel.",2,null],[13,"KernelStack","","Memory used for the kernel stack.",2,null],[13,"PageTable","","Memory used for creating page tables.",2,null],[13,"Bootloader","","Memory used by the bootloader.",2,null],[13,"FrameZero","","Frame at address zero.",2,null],[13,"Empty","","An empty region with size 0",2,null],[13,"BootInfo","","Memory used for storing the boot information.",2,null],[13,"Package","","Memory used for storing the supplied package",2,null],[3,"BootInfo","","This structure represents the information that the …",null,null],[12,"memory_map","","A map of the physical memory regions of the underlying …",3,null],[12,"physical_memory_offset","","The offset into the virtual address space where the …",3,null],[11,"tls_template","","Returns information about the thread local storage …",3,[[],[["option",4],["tlstemplate",3]]]],[3,"TlsTemplate","","Information about the thread local storage (TLS) template.",null,null],[12,"start_addr","","The virtual start address of the thread local storage …",4,null],[12,"file_size","","The number of data bytes in the template.",4,null],[12,"mem_size","","The total number of bytes that the TLS segment should …",4,null],[14,"entry_point","bootloader","Defines the entry point function.",null,null],[11,"from","bootloader::bootinfo","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"into","","",5,[[]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"into","","",3,[[]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"into","","",4,[[]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"deref","","",5,[[]]],[11,"deref_mut","","",5,[[]]],[11,"fmt","","",5,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",4,[[["formatter",3]],["result",6]]],[11,"eq","","",0,[[["memoryregion",3]]]],[11,"ne","","",0,[[["memoryregion",3]]]],[11,"eq","","",1,[[["framerange",3]]]],[11,"ne","","",1,[[["framerange",3]]]],[11,"eq","","",2,[[["memoryregiontype",4]]]],[11,"eq","","",4,[[["tlstemplate",3]]]],[11,"ne","","",4,[[["tlstemplate",3]]]],[11,"clone","","",0,[[],["memoryregion",3]]],[11,"clone","","",1,[[],["framerange",3]]],[11,"clone","","",2,[[],["memoryregiontype",4]]],[11,"clone","","",4,[[],["tlstemplate",3]]],[11,"new","","Create a new FrameRange from the passed start_addr and …",1,[[]]],[11,"is_empty","","Returns true if the frame range contains no frames.",1,[[]]],[11,"start_addr","","Returns the physical start address of the memory region.",1,[[]]],[11,"end_addr","","Returns the physical end address of the memory region.",1,[[]]]],"p":[[3,"MemoryRegion"],[3,"FrameRange"],[4,"MemoryRegionType"],[3,"BootInfo"],[3,"TlsTemplate"],[3,"MemoryMap"]]},\
"lazy_static":{"doc":"A macro for declaring lazily evaluated statics.","i":[[8,"LazyStatic","lazy_static","Support trait for enabling a few common operation on lazy …",null,null],[5,"initialize","","Takes a shared reference to a lazy static and initializes …",null,[[]]],[14,"lazy_static","","",null,null]],"p":[]},\
"spin":{"doc":"Synchronization primitives based on spinning","i":[[3,"Mutex","spin","This type provides MUTual EXclusion based on spinning.",null,null],[3,"MutexGuard","","A guard to which the protected data can be accessed",null,null],[3,"RwLock","","A reader-writer lock",null,null],[3,"RwLockReadGuard","","A guard from which the protected data can be read",null,null],[3,"RwLockWriteGuard","","A guard to which the protected data can be written",null,null],[3,"RwLockUpgradeableGuard","","A guard from which the protected data can be read, and …",null,null],[3,"Once","","A synchronization primitive which can be used to run a …",null,null],[11,"from","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"into","","",3,[[]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"into","","",4,[[]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"into","","",5,[[]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","","",6,[[]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"into","","",6,[[]]],[11,"try_into","","",6,[[],["result",4]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"deref","","",1,[[]]],[11,"deref","","",3,[[]]],[11,"deref","","",5,[[]]],[11,"deref","","",4,[[]]],[11,"deref_mut","","",1,[[]]],[11,"deref_mut","","",4,[[]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",4,[[["formatter",3]],["result",6]]],[11,"fmt","","",5,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",6,[[["formatter",3]],["result",6]]],[11,"drop","","The dropping of the MutexGuard will release the lock it …",1,[[]]],[11,"drop","","",3,[[]]],[11,"drop","","",5,[[]]],[11,"drop","","",4,[[]]],[11,"default","","",0,[[],["mutex",3]]],[11,"default","","",2,[[],["rwlock",3]]],[11,"new","","Creates a new spinlock wrapping the supplied data.",0,[[],["mutex",3]]],[11,"into_inner","","Consumes this mutex, returning the underlying data.",0,[[]]],[11,"lock","","Locks the spinlock and returns a guard.",0,[[],["mutexguard",3]]],[11,"force_unlock","","Force unlock the spinlock.",0,[[]]],[11,"try_lock","","Tries to lock the mutex. If it is already locked, it will …",0,[[],[["option",4],["mutexguard",3]]]],[11,"new","","Creates a new spinlock wrapping the supplied data.",2,[[],["rwlock",3]]],[11,"into_inner","","Consumes this <code>RwLock</code>, returning the underlying data.",2,[[]]],[11,"read","","Locks this rwlock with shared read access, blocking the …",2,[[],["rwlockreadguard",3]]],[11,"try_read","","Attempt to acquire this lock with shared read access.",2,[[],[["option",4],["rwlockreadguard",3]]]],[11,"force_read_decrement","","Force decrement the reader count.",2,[[]]],[11,"force_write_unlock","","Force unlock exclusive write access.",2,[[]]],[11,"write","","Lock this rwlock with exclusive write access, blocking …",2,[[],["rwlockwriteguard",3]]],[11,"try_write","","Attempt to lock this rwlock with exclusive write access.",2,[[],[["option",4],["rwlockwriteguard",3]]]],[11,"upgradeable_read","","Obtain a readable lock guard that can later be upgraded …",2,[[],["rwlockupgradeableguard",3]]],[11,"try_upgradeable_read","","Tries to obtain an upgradeable lock guard.",2,[[],[["option",4],["rwlockupgradeableguard",3]]]],[11,"upgrade","","Upgrades an upgradeable lock guard to a writable lock …",5,[[],["rwlockwriteguard",3]]],[11,"try_upgrade","","Tries to upgrade an upgradeable lock guard to a writable …",5,[[],[["rwlockwriteguard",3],["result",4]]]],[11,"downgrade","","Downgrades the upgradeable lock guard to a readable, …",5,[[],["rwlockreadguard",3]]],[11,"downgrade","","Downgrades the writable lock guard to a readable, shared …",4,[[],["rwlockreadguard",3]]],[18,"INIT","","Initialization constant of <code>Once</code>.",6,null],[11,"new","","Creates a new <code>Once</code> value.",6,[[],["once",3]]],[11,"call_once","","Performs an initialization routine once and only once. …",6,[[]]],[11,"try","","Returns a pointer iff the <code>Once</code> was previously initialized",6,[[],["option",4]]],[11,"wait","","Like try, but will spin if the <code>Once</code> is in the process of …",6,[[],["option",4]]]],"p":[[3,"Mutex"],[3,"MutexGuard"],[3,"RwLock"],[3,"RwLockReadGuard"],[3,"RwLockWriteGuard"],[3,"RwLockUpgradeableGuard"],[3,"Once"]]},\
"volatile":{"doc":"Provides wrapper types <code>Volatile</code>, <code>ReadOnly</code>, <code>WriteOnly</code>, …","i":[[3,"Volatile","volatile","A wrapper type around a volatile variable, which allows …",null,null],[11,"new","","Construct a new volatile instance wrapping the given …",0,[[],["volatile",3]]],[11,"read","","Performs a volatile read of the contained value, …",0,[[]]],[11,"write","","Performs a volatile write, setting the contained value to …",0,[[]]],[11,"update","","Performs a volatile read of the contained value, passes a …",0,[[]]],[3,"ReadOnly","","A volatile wrapper which only allows read operations.",null,null],[11,"new","","Construct a new read-only volatile wrapper wrapping the …",1,[[],["readonly",3]]],[11,"read","","Perform a volatile read of the contained value, returning …",1,[[]]],[3,"WriteOnly","","A volatile wrapper which only allows write operations.",null,null],[11,"new","","Constructs a new write only volatile wrapper around the …",2,[[],["writeonly",3]]],[11,"write","","Performs a volatile write of value <code>value</code> into the …",2,[[]]],[6,"ReadWrite","","A volatile wrapper which allows both read and write …",null,null],[11,"from","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"clone","","",0,[[]]],[11,"clone","","",1,[[],["readonly",3]]],[11,"clone","","",2,[[],["writeonly",3]]],[11,"default","","",0,[[],["volatile",3]]],[11,"default","","",1,[[],["readonly",3]]],[11,"default","","",2,[[],["writeonly",3]]]],"p":[[3,"Volatile"],[3,"ReadOnly"],[3,"WriteOnly"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);