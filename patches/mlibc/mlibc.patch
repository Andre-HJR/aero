From 3f789791be46cefe9ff8a5c6196a3a23bed9620f Mon Sep 17 00:00:00 2001
From: Andy-Python-Programmer <andypythonappdeveloper@gmail.com>
Date: Sun, 16 Apr 2023 14:21:09 +1000
Subject: [PATCH] <xxx>

Signed-off-by: Andy-Python-Programmer <andypythonappdeveloper@gmail.com>
---
 .gitignore                            |  2 ++
 options/ansi/generic/stdlib-stubs.cpp |  6 +++--
 options/glibc/generic/execinfo.cpp    |  5 ++--
 options/rtdl/generic/linker.cpp       |  2 +-
 sysdeps/aero/generic/aero.cpp         | 27 +++++++++++++++-------
 sysdeps/aero/generic/filesystem.cpp   | 33 ++++++++++++++-------------
 sysdeps/aero/generic/sockets.cpp      | 29 +++++++++++++++++++++--
 sysdeps/aero/include/aero/syscall.h   | 10 ++++++++
 8 files changed, 83 insertions(+), 31 deletions(-)

diff --git a/.gitignore b/.gitignore
index fdd60a0..9f811f4 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,3 +3,5 @@ subprojects
 *.xbstrap
 # editor configs:
 .vscode
+# clangd cache files:
+.cache
diff --git a/options/ansi/generic/stdlib-stubs.cpp b/options/ansi/generic/stdlib-stubs.cpp
index c33dfba..ec8baa4 100644
--- a/options/ansi/generic/stdlib-stubs.cpp
+++ b/options/ansi/generic/stdlib-stubs.cpp
@@ -396,8 +396,10 @@ int mbtowc(wchar_t *__restrict wc, const char *__restrict mb, size_t max_size) {
 			mlibc::code_seq<wchar_t> wseq{wc, wc + 1};
 			mlibc::code_seq<const char> nseq{mb, mb + max_size};
 			auto e = cc->decode_wtranscode(nseq, wseq, mbtowc_state);
-			if (e != mlibc::charcode_error::null)
-				__ensure(!"decode_wtranscode() errors are not handled");
+			if (e != mlibc::charcode_error::null) {
+				errno = EILSEQ;
+				return -1;
+			}
 
 			return nseq.it - mb;
 		} else {
diff --git a/options/glibc/generic/execinfo.cpp b/options/glibc/generic/execinfo.cpp
index 3474615..10a2109 100644
--- a/options/glibc/generic/execinfo.cpp
+++ b/options/glibc/generic/execinfo.cpp
@@ -1,9 +1,10 @@
 #include <execinfo.h>
 #include <bits/ensure.h>
+#include <mlibc/debug.hpp>
 
 int backtrace(void **, int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+	mlibc::infoLogger() << "backtrace() is unimplemented" << frg::endlog;
+	return 0;
 }
 
 char **backtrace_symbols(void *const *, int) {
diff --git a/options/rtdl/generic/linker.cpp b/options/rtdl/generic/linker.cpp
index 003a162..ab01a7a 100644
--- a/options/rtdl/generic/linker.cpp
+++ b/options/rtdl/generic/linker.cpp
@@ -18,7 +18,7 @@ uintptr_t libraryBase = 0x41000000;
 
 constexpr bool verbose = false;
 constexpr bool stillSlightlyVerbose = false;
-constexpr bool logBaseAddresses = false;
+constexpr bool logBaseAddresses = true;
 constexpr bool logRpath = false;
 constexpr bool eagerBinding = true;
 
diff --git a/sysdeps/aero/generic/aero.cpp b/sysdeps/aero/generic/aero.cpp
index 6eeb980..e6bd277 100644
--- a/sysdeps/aero/generic/aero.cpp
+++ b/sysdeps/aero/generic/aero.cpp
@@ -176,13 +176,6 @@ int sys_kill(int pid, int sig) {
     return 0;
 }
 
-int sys_getpgid(pid_t pid, pid_t *pgid) {
-    mlibc::infoLogger() << "sys_getpgid() is unimplemented" << frg::endlog;
-    *pgid = 0;
-
-    return 0;
-}
-
 int sys_clock_get(int clock, time_t *secs, long *nanos) {
     struct timespec ts;
     auto result = syscall(SYS_GETTIME, clock, &ts);
@@ -239,6 +232,21 @@ int sys_sleep(time_t *sec, long *nanosec) {
     return 0;
 }
 
+pid_t sys_getpgid(pid_t pid, pid_t *pgid) {
+    auto ret = syscall(SYS_GETPGID, pid);
+    if(int e = sc_error(ret); e)
+        return e;
+    *pgid = ret;
+    return 0;
+}
+
+int sys_setpgid(pid_t pid, pid_t pgid) {
+    auto ret = syscall(SYS_SETPGID, pid, pgid);
+    if(int e = sc_error(ret); e)
+		return e;
+	return 0;
+}
+
 uid_t sys_getuid() {
     mlibc::infoLogger() << "mlibc: sys_setuid is a stub" << frg::endlog;
     return 0;
@@ -250,7 +258,10 @@ uid_t sys_geteuid() {
 }
 
 int sys_setsid(pid_t *sid) {
-    mlibc::infoLogger() << "mlibc: sys_setsid is a stub" << frg::endlog;
+    auto ret = syscall(SYS_SETSID);
+    if(int e = sc_error(ret); e)
+        return e;
+    *sid = ret;
     return 0;
 }
 
diff --git a/sysdeps/aero/generic/filesystem.cpp b/sysdeps/aero/generic/filesystem.cpp
index a2c483b..fa5a369 100644
--- a/sysdeps/aero/generic/filesystem.cpp
+++ b/sysdeps/aero/generic/filesystem.cpp
@@ -155,14 +155,16 @@ int sys_tcgetattr(int fd, struct termios *attr) {
 }
 
 int sys_tcsetattr(int fd, int optional_action, const struct termios *attr) {
-    if (optional_action)
-        mlibc::infoLogger()
-            << "mlibc: warning: sys_tcsetattr ignores optional_action"
-            << frg::endlog;
+    int req;
 
-    int result;
+    switch (optional_action) {
+		case TCSANOW: req = TCSETS; break;
+		case TCSADRAIN: req = TCSETSW; break;
+		case TCSAFLUSH: req = TCSETSF; break;
+		default: return EINVAL;
+	}
 
-    if (int e = sys_ioctl(fd, TCSETSF, (void *)attr, &result); e)
+    if (int e = sys_ioctl(fd, req, (void *)attr, NULL); e)
         return e;
 
     return 0;
@@ -178,9 +180,7 @@ int sys_mkdir(const char *path, mode_t) {
     return 0;
 }
 
-int sys_rmdir(const char *path) UNIMPLEMENTED("sys_rmdir")
-
-    int sys_link(const char *srcpath, const char *destpath) {
+int sys_link(const char *srcpath, const char *destpath) {
     auto result =
         syscall(SYS_LINK, srcpath, strlen(srcpath), destpath, strlen(destpath));
 
@@ -191,14 +191,15 @@ int sys_rmdir(const char *path) UNIMPLEMENTED("sys_rmdir")
     return 0;
 }
 
-int sys_unlinkat(int fd, const char *path, int flags) {
-    auto result = syscall(SYS_UNLINK, fd, path, strlen(path), flags);
-
-    if (result < 0) {
-        return -result;
-    }
+int sys_rmdir(const char *path) {
+    return sys_unlinkat(AT_FDCWD, path, AT_REMOVEDIR);
+}
 
-    return 0;
+int sys_unlinkat(int fd, const char *path, int flags) {
+	auto ret = syscall(SYS_UNLINK, fd, path, strlen(path), flags);
+	if (int e = sc_error(ret); e)
+		return e;
+	return 0;
 }
 
 struct aero_dir_entry {
diff --git a/sysdeps/aero/generic/sockets.cpp b/sysdeps/aero/generic/sockets.cpp
index 4db9956..4cb3ee8 100644
--- a/sysdeps/aero/generic/sockets.cpp
+++ b/sysdeps/aero/generic/sockets.cpp
@@ -5,7 +5,11 @@
 #include <abi-bits/errno.h>
 
 #include <aero/syscall.h>
+
+#include <unistd.h>
 #include <stdint.h>
+#include <net/if.h>
+#include <sys/ioctl.h>
 
 namespace {
 
@@ -210,10 +214,31 @@ int sys_setsockopt(int fd, int layer, int number, const void *buffer,
                             << frg::endlog;
         return 0;
     } else {
-        mlibc::panicLogger()
+        mlibc::infoLogger()
             << "\e[31mmlibc: Unexpected setsockopt() call, layer: " << layer
             << " number: " << number << "\e[39m" << frg::endlog;
-        __builtin_unreachable();
+        return 0;
     }
 }
+
+int sys_if_nametoindex(const char *name, unsigned int *ret) {
+    int fd = 0;
+
+    // TODO(andypython): is the SOCK_CLOEXEC flag required in this case?
+    int r = sys_socket(AF_INET, SOCK_DGRAM, AF_UNSPEC, &fd);
+    if (r)
+        return r;
+
+    struct ifreq ifr;
+    strncpy(ifr.ifr_name, name, sizeof ifr.ifr_name);
+
+    r = sys_ioctl(fd, SIOCGIFINDEX, &ifr, NULL);
+    close(fd);
+
+    if (r)
+        return r;
+
+    *ret = ifr.ifr_ifindex;
+    return 0;
+}
 } // namespace mlibc
diff --git a/sysdeps/aero/include/aero/syscall.h b/sysdeps/aero/include/aero/syscall.h
index aa642e5..d8bf99e 100644
--- a/sysdeps/aero/include/aero/syscall.h
+++ b/sysdeps/aero/include/aero/syscall.h
@@ -75,6 +75,10 @@
 #define SYS_RENAME 68
 #define SYS_MPROTECT 69
 #define SYS_SOCK_SEND 70
+#define SYS_TRACE 71
+#define SYS_SETPGID 72
+#define SYS_SETSID 73
+#define SYS_GETPGID 74
 
 // Invalid syscall used to trigger a log error in the kernel (as a hint)
 // so, that we can implement the syscall in the kernel.
@@ -217,4 +221,10 @@ __attribute__((__always_inline__)) static inline long syscall(sc_word_t call,
                                                           T... args) {
     return _syscall(call, sc_cast(args)...);
 }
+
+inline int sc_error(long ret) {
+    if (ret < 0)
+        return -ret;
+    return 0;
+}
 #endif // SYSCALL_H
-- 
2.40.1

